I want to get this proposal in front of the crew close to ZLint and the ZMap org in general. The plan is to revise this text and eventually submit it to the CA community via the mailing list.

# Purpose [WIP]

The information provided to ZLint today is the information present within the target certificate itself. However, policies often contain requirements based on information that are not encoded in any x509 certificate. When attempting to encode this policy within ZLint, the lint in question becomes non-deterministic as non enough information is known to give a definitive answer.

@TODO explaining problems are harder than writing the code that fixes it.

@TODO compile list of open issues/PRs that are blocked on this

# Example Lints

### Contrived Examples

```go
package cabf_br

import (
	"github.com/zmap/zcrypto/x509"
	"github.com/zmap/zlint/v3/lint"
	"github.com/zmap/zlint/v3/util"
)


type LintItselfIsConfigurable struct {
	BottlesOfBeerOnTheWall int `comment:"This MUST be set to the number of bottles of beer that were on the signing CAs wall at the time of issuance."`
	ISpyWithMyLittleEye    struct {
		Descriptions []string `comment:"Any number of descriptions that are valid for the subject."`
		Subject      string
	} `toml:"i_spy_with_my_little_eye"`
}

func init() {
	lint.RegisterLint(&lint.Lint{
		Name:          "e_ca_too_few_beers",
		Description:   "CA Certificates MUST have at least 99 beers.",
		Citation:      "BRs: 7.1.4.3.1",
		Source:        lint.CABFBaselineRequirements,
		EffectiveDate: util.CABV148Date,
		Lint:          NewLintItselfIsConfigurable,
	})
}

func NewLintItselfIsConfigurable() lint.LintInterface {
	// Go code encourages that the zero value for a struct be valid, however
	// if you wish for your Lint to have non-zero defaults then your constructor is
	// the place to do so. The value initialized in this constructor WILL appear
	// in the example configuration printed through the `-exampleConfig flag`.
	return &LintItselfIsConfigurable{ISpyWithMyLittleEye: struct {
		Descriptions []string `comment:"Any number of descriptions that are valid for the subject."`
		Subject      string
	}{Descriptions: []string{"larger than a bread box", "smaller than a barn"}, Subject: "A car"}}
}

// In this case, the struct that is the lint itself is the target for configuration.
func (l *LintItselfIsConfigurable) Configure() interface{} {
	return l
}

func (l *LintItselfIsConfigurable) CheckApplies(c *x509.Certificate) bool {
	return util.IsCACert(c)
}

func (l *LintItselfIsConfigurable) Execute(c *x509.Certificate) *lint.LintResult {
	if l.BottlesOfBeerOnTheWall < 99 {
		return &lint.LintResult{Status: lint.Error}
	} else {
		return &lint.LintResult{Status: lint.Pass}
	}
}
```

```go
package cabf_br

import (
	"github.com/zmap/zcrypto/x509"
	"github.com/zmap/zlint/v3/lint"
	"github.com/zmap/zlint/v3/util"
)


type LintEmbedsAConfiguration struct {
	configuration                        embeddedConfiguration
	SomeOtherFieldThatWeDontWantToExpose int
}

type embeddedConfiguration struct {
	IsWebPKI bool `toml:"is_web_pki" comment:"Indicates that the certificate is intended for the Web PKI."`
}

func init() {
	lint.RegisterLint(&lint.Lint{
		Name:          "w_web_pki_cert",
		Description:   "CA Certificates SHOULD....something....about the web pki",
		Citation:      "BRs: 7.1.4.3.1",
		Source:        lint.CABFBaselineRequirements,
		EffectiveDate: util.CABV148Date,
		Lint:          NewLintEmbedsAConfiguration,
	})
}

// A pointer to an embedded struct may be passed to the framework
// if the author does not wish to expose certain fields in their primary struct.
func (l *LintEmbedsAConfiguration) Configure() interface{} {
	return &l.configuration
}

func NewLintEmbedsAConfiguration() lint.LintInterface {
	return &LintEmbedsAConfiguration{configuration: embeddedConfiguration{}}
}

func (l *LintEmbedsAConfiguration) CheckApplies(c *x509.Certificate) bool {
	return util.IsCACert(c)
}

func (l *LintEmbedsAConfiguration) Execute(c *x509.Certificate) *lint.LintResult {
	if l.configuration.IsWebPKI {
		return &lint.LintResult{Status: lint.Warn}
	} else {
		return &lint.LintResult{Status: lint.Pass}
	}
}
```

```bash
./zlint -exampleConfig
```

```toml
[e_ca_too_few_beers]
# This MUST be set to the number of bottles of beer that were on the signing CAs wall at the time of issuance.
BottlesOfBeerOnTheWall = 0

[e_ca_too_few_beers.i_spy_with_my_little_eye]
# Any number of descriptions that are valid for the subject.
Descriptions = ["larger than a bread box", "smaller than a barn"]
Subject = "A car"

[w_web_pki_cert]
# Indicates that the certificate is intended for the Web PKI.
is_web_pki = false
```

Note that comments declared in the provided `structs` ARE present within example configuration generated by for operators. As such, lint authors SHOULD provide comments describing the purposes of the fields as well as the impact that those fields have on their given lint.

<a name="live_example"></a>
# Live Example

```go
package cabf_br

import (
	"github.com/zmap/zcrypto/x509"
	"github.com/zmap/zlint/v3/lint"
	"github.com/zmap/zlint/v3/util"
)

func init() {
	lint.RegisterLint(&lint.Lint{
		Name:          "e_sub_ca_eku_incompatible_values",
		Description:   "Subordinate CA extkeyUsage: if serverAuth is present, then emailProtection, codeSigning, timeStamping, and anyExtendedKeyUsage MUST NOT be present.",
		Citation:      "BRs: 7.1.2.2",
		Source:        lint.CABFBaselineRequirements,
		EffectiveDate: util.CABFBRs_1_7_1_Date,
		Lint:          NewSubCAEkuIncompatibleValues,
	})
}

type subCAEkuIncompatibleValues struct {
	CrossSignerPEM string `comment:"Section 7.1.2.2: For Cross Certificates that share a Subject Distinguished Name and Subject Public Key with a Root Certificate operated in accordance with these Requirements, this extension MAY be present. If present, this extension SHOULD NOT be marked critical. This extension MUST only contain usages for which the issuing CA has verified the Cross Certificate is authorized to assert. This extension MAY contain the anyExtendedKeyUsage [RFC5280] usage, if the Root Certificate(s) associated with this Cross Certificate are operated by the same organization as the issuing Root Certificate."`
}

func (l *subCAEkuIncompatibleValues) Configure() interface{} {
	return l
}

func NewSubCAEkuIncompatibleValues() lint.LintInterface {
	return &subCAEkuIncompatibleValues{}
}

func (l *subCAEkuIncompatibleValues) CheckApplies(c *x509.Certificate) bool {
	return util.IsSubCA(c) && util.IsExtInCert(c, util.EkuSynOid)
}

func (l *subCAEkuIncompatibleValues) Execute(c *x509.Certificate) *lint.LintResult {
	// Check if l.CrossSigner was provided.
	// Parse to cert.
	// Do appropriate checks against section 7.1.2.2
	...
}
```

This structure generates the following configuration.

```toml
[e_sub_ca_eku_incompatible_values]
# Section 7.1.2.2:  For Cross Certificates that share a Subject Distinguished Name and Subject Public Key with a Root Certificate operated in accordance with these Requirements, this extension MAY be present. If present, this extension SHOULD NOT be marked critical. This extension MUST only contain usages for which the issuing CA has verified the Cross Certificate is authorized to assert. This extension MAY contain the anyExtendedKeyUsage [RFC5280] usage, if the Root Certificate(s) associated with this Cross Certificate are operated by the same organization as the issuing Root Certificate.
CrossSignerPEM = ""
```


With the cross signer certificate filled in...
```toml
[e_sub_ca_eku_incompatible_values]
CrossSignerPEM = """
-----BEGIN CERTIFICATE-----
MIIBBDCBrKADAgECAgEBMAoGCCqGSM49BAMCMAAwIhgPMDAwMTAxMDEwMDAwMDBa
GA85OTk4MTEzMDAwMDAwMFowADBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABDaq
E7tJ1D0lKPlIYcMylZ47WsEAFypRlBVUni+Q8ZY4S+NPVHFDxpZ/Qzx8qnXmHvf6
8caqXJthylrSzH1HVGGjEzARMA8GA1UdEwEB/wQFMAMBAf8wCgYIKoZIzj0EAwID
RwAwRAIgJklSU+eEIOc+oUHa/ugiNsBpTsrrrJudXuZ41hayNQsCIEwxc3quig63
ZI7LhYni7wlyXJBiXUlQkuacCGdqkv+/
-----END CERTIFICATE-----
"""
```

# Example Usages

### Retrieving an Example Configuration
```bash
$ ./zlint -exampleConfig > config.toml
$ cat config.toml
[e_sub_ca_eku_incompatible_values]
CrossSignerPEM = ""
```

### Running Against a Configuration.
```bash
$ cat >> config.toml << EOF
[e_sub_ca_eku_incompatible_values]
CrossSignerPEM = """
-----BEGIN CERTIFICATE-----
MIIBBDCBrKADAgECAgEBMAoGCCqGSM49BAMCMAAwIhgPMDAwMTAxMDEwMDAwMDBa
GA85OTk4MTEzMDAwMDAwMFowADBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABDaq
E7tJ1D0lKPlIYcMylZ47WsEAFypRlBVUni+Q8ZY4S+NPVHFDxpZ/Qzx8qnXmHvf6
8caqXJthylrSzH1HVGGjEzARMA8GA1UdEwEB/wQFMAMBAf8wCgYIKoZIzj0EAwID
RwAwRAIgJklSU+eEIOc+oUHa/ugiNsBpTsrrrJudXuZ41hayNQsCIEwxc3quig63
ZI7LhYni7wlyXJBiXUlQkuacCGdqkv+/
-----END CERTIFICATE-----
"""
EOF
$ ./zlint -config config.toml /path/to/cert/to/lint
```

# Choice of TOML

## vs. JSON
JSON does not allow for comments in its documents. This alone is the primary disqualifier.

Comments from lint authors to CAs are very important for conveying the purpose and impact of individual fields. Additionally, it is likely that CAs will version control (and possibly even template) their own configurations, in which case it is an attractive proposition that CAs be able to leave comments in their internal configurations  in order to track their own policy decisions.

## vs. YAML

YAML allows for comments. However, it is a far richer (and thus far more complex) lanuage than TOML is. It is not uncommon for humans to have difficulty writing and editing YAML by hand.

Should use cases arise such that the complexity of YAML becomes desirable then it may be a consideration for usage.

# Dissatisfactions
## Long Single Line Comments
Lint authors provide comments in their configurations via the `comment:"<text>"` Go tag. Unfortunately, Go does not allow for multiline tags nor does it all for usages of `const` or `var` strings within tags - all tags must be string literals. This means that, as is, it is very likely that majority of comments are going to break code style rules simply by being even reasonably descriptive. This is seen immediately in the example provided in [Live Example](#live_example).

There may be remediation to this. One is to have an implicit, reflective, interface.

1. Find all public fields within the struct.
2. For every public field, attempt to find a public method named `<Field>Comment` that returns a string.

```go
type MyLint struct {
	CrossSigner string
}

func CrossSignerComment() string {
	return `
For Cross Certificates that share a Subject Distinguished Name and 
Subject Public Key with a Root Certificate operated in accordance 
with these Requirements, this extension MAY be present. If present, 
this extension SHOULD NOT be marked critical. This extension MUST 
only contain usages for which the issuing CA has verified the 
Cross Certificate is authorized to assert. This extension MAY contain 
the anyExtendedKeyUsage [RFC5280] usage, if the Root Certificate(s) 
associated with this Cross Certificate are operated by the same 
organization as the issuing Root Certificate.
`
}
```

However, spike work has not yet been done on accomplishing an interface such as this. As such it is not yet known how conducive our TOML framework would be towards being extended in such a way.

## Manual Certificate Parsing

The TOML serde framework does not have a notion of x509 certificates and, as such, lint authors are backed into the wall of declaring `string`
fields and documenting that they MUST be properly formatted PEMs and then do the parsing and error handling themselves. This is seen in the [Live Example](#live_example).

Possible remediations include:

* Providing a shim `struct` that both knows how to deserialize from TOML _and_ how to convert itself into a `*x509.Certificate`.

```go
type MyLint struct {
	CrossSigner *TomlCertificate
}

func (m *MyLint) Execute() {
	var cert *x509.Certificate = m.CrossSigner.GetCertificate()
}
```

* Provide `utils` facilites.

```go
type MyLint struct {
	CrossSigner string
}

func (m *MyLint) Execute() {
	var cert *x509.Certificate = utils.CertificateFromToml(m.CrossSigner)
}
```

# What is missing

### Higher Scoped Configurations

This proposal does not have an answer for having higher scoped configurations. It may be attractive to have scoping rules such as the following.

```toml
# Global configurations available to all lints.
...
...
web_pki = true
...
...

# Category local configurations.
[cabf_br]
...

[rfc]
...

[etsi]
...

# And then lint local configurations.
[e_sub_ca_eku_incompatible_values]
# Section 7.1.2.2:  For Cross Certificates that share a Subject Distinguished Name and Subject Public Key with a Root Certificate operated in accordance with these Requirements, this extension MAY be present. If present, this extension SHOULD NOT be marked critical. This extension MUST only contain usages for which the issuing CA has verified the Cross Certificate is authorized to assert. This extension MAY contain the anyExtendedKeyUsage [RFC5280] usage, if the Root Certificate(s) associated with this Cross Certificate are operated by the same organization as the issuing Root Certificate.
CrossSignerPEM = ""
```
